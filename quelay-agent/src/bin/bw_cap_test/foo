//! Tuner actor — one sender and one receiver per stream pair.
//!
//! # Sender tuner lifecycle
//!
//! 1. Waits for [`TunerCmd::Port`] from CIC
//! 2. Connects TCP to that port, pumps `payload` in a `spawn_blocking` task
//! 3. On [`TunerCmd::Shutdown`] — signals the writer to close the socket (EOF)
//! 4. Waits for [`TunerCmd::Done`] or [`TunerCmd::Failed`] from CIC
//! 5. Sends [`CicMsg::TunerFinished`] and returns `Ok(())`
//!
//! # Receiver tuner lifecycle
//!
//! 1. Waits for [`TunerCmd::Port`] from CIC
//! 2. Connects TCP, reads until EOF counting bytes (no buffering)
//! 3. Waits for [`TunerCmd::Done`] or [`TunerCmd::Failed`] from CIC
//! 4. Sends [`CicMsg::TunerFinished`] and returns `Ok(())`
//!
//! sha256 verification is **skipped** — transfers are intentionally partial.

use std::time::{Duration, Instant};

// ---

use tokio::sync::mpsc;

// ---

use super::CicHandle;
use super::CicMsg;
use super::Role;

// ---------------------------------------------------------------------------
// TunerCmd
// ---------------------------------------------------------------------------

/// Commands sent from CIC to a tuner task.
#[derive(Debug, Clone)]
pub enum TunerCmd {
    /// CIC → tuner: agent opened this ephemeral port; connect to it.
    Port(u16),

    /// CIC → tuner: agent confirmed the stream finished normally.
    Done { role: Role, bytes: u64 },

    /// CIC → tuner: agent reported a stream failure.
    Failed { role: Role, reason: String },

    /// CIC → sender tuner: duration elapsed, close the write socket.
    Shutdown,

    /// CIC → any tuner: failsafe abort.
    Kill,
}

// ---------------------------------------------------------------------------
// TunerOutcome / TunerResult
// ---------------------------------------------------------------------------

/// Outcome of a single tuner task.
#[derive(Debug, Clone)]
pub enum TunerOutcome {
    Pass,
    Fail { reason: String },
}

// ---

/// Result reported by a tuner task to CIC via [`CicMsg::TunerFinished`].
#[derive(Debug, Clone)]
pub struct TunerResult {
    pub uuid: String,
    pub role: Role,
    pub outcome: TunerOutcome,
    pub bytes: u64,
    pub elapsed: Duration,
}

// ---------------------------------------------------------------------------
// spawn_sender
// ---------------------------------------------------------------------------

/// Spawn a sender tuner task.  The join handle returns `Ok(())` on clean exit
/// or `Err` on panic — results are reported to CIC via [`CicMsg::TunerFinished`].
pub fn spawn_sender(
    uuid: String,
    payload: Vec<u8>,
    mut cmd_rx: mpsc::Receiver<TunerCmd>,
    cic: CicHandle,
) -> tokio::task::JoinHandle<anyhow::Result<()>> {
    // ---
    tokio::spawn(async move {
        // ---
        let t_start = Instant::now();

        // --- wait for ephemeral port ---
        let port = loop {
            match cmd_rx.recv().await {
                Some(TunerCmd::Port(p)) => break p,
                Some(TunerCmd::Kill) => {
                    finish(&cic, killed(&uuid, Role::Sender, t_start)).await;
                    return Ok(());
                }
                Some(other) => {
                    tracing::warn!(%uuid, ?other, "sender: unexpected cmd awaiting port")
                }
                None => {
                    finish(&cic, disconnected(&uuid, Role::Sender, t_start)).await;
                    return Ok(());
                }
            }
        };

        tracing::info!(%uuid, port, "sender: connecting");

        // --- spawn blocking TCP writer ---
        let (abort_tx, mut abort_rx) = tokio::sync::oneshot::channel::<()>();

        let write_handle: tokio::task::JoinHandle<anyhow::Result<u64>> =
            tokio::task::spawn_blocking(move || {
                use std::io::Write;
                let mut tcp = std::net::TcpStream::connect(format!("127.0.0.1:{port}"))?;
                tcp.set_write_timeout(Some(Duration::from_millis(100)))?; // <-- add this
                let mut sent = 0u64;
                for chunk in payload.chunks(64 * 1024) {
                    if abort_rx.try_recv().is_ok() {
                        tracing::info!("sender: abort received, closing socket");
                        break;
                    }
                    match tcp.write_all(chunk) {
                        Ok(()) => sent += chunk.len() as u64,
                        Err(e)
                            if e.kind() == std::io::ErrorKind::WouldBlock
                                || e.kind() == std::io::ErrorKind::TimedOut =>
                        {
                            // Timeout — check abort signal and retry or exit
                            if abort_rx.try_recv().is_ok() {
                                tracing::info!("sender: abort received after write timeout");
                                break;
                            }
                            // else keep trying — could retry the chunk here, but
                            // for bw-cap-test dropping it is fine
                            break;
                        }
                        Err(e) => return Err(e.into()),
                    }
                }
                Ok(sent)
            });

        // --- wait for Shutdown / Kill (or early stream completion) ---
        let bytes_written: u64 = loop {
            match cmd_rx.recv().await {
                Some(TunerCmd::Shutdown) => {
                    tracing::info!(%uuid, "sender: shutdown, aborting write task");
                    let _ = abort_tx.send(());
                    let n = match write_handle.await {
                        Ok(Ok(n)) => n,
                        Ok(Err(e)) => {
                            tracing::warn!(%uuid, "write task error: {e}");
                            0
                        }
                        Err(_) => 0,
                    };
                    break n;
                }

                Some(TunerCmd::Kill) => {
                    write_handle.abort();
                    finish(&cic, killed(&uuid, Role::Sender, t_start)).await;
                    return Ok(());
                }

                // Payload exhausted before shutdown — unlikely in bw-cap-test
                // but handle it gracefully.
                Some(TunerCmd::Done { bytes, .. }) => {
                    let _ = write_handle.await;
                    break bytes;
                }

                Some(TunerCmd::Failed { reason, .. }) => {
                    write_handle.abort();
                    finish(&cic, fail(&uuid, Role::Sender, reason, t_start)).await;
                    return Ok(());
                }

                Some(other) => tracing::warn!(%uuid, ?other, "sender: unexpected cmd"),
                None => {
                    write_handle.abort();
                    finish(&cic, disconnected(&uuid, Role::Sender, t_start)).await;
                    return Ok(());
                }
            }
        };

        // --- wait for agent's Done / Failed after the socket was closed ---
        let final_bytes: u64 = loop {
            match cmd_rx.recv().await {
                Some(TunerCmd::Done { bytes, .. }) => break bytes,
                Some(TunerCmd::Failed { reason, .. }) => {
                    finish(&cic, fail(&uuid, Role::Sender, reason, t_start)).await;
                    return Ok(());
                }
                Some(TunerCmd::Kill) => {
                    finish(&cic, killed(&uuid, Role::Sender, t_start)).await;
                    return Ok(());
                }
                Some(other) => {
                    tracing::warn!(%uuid, ?other, "sender: unexpected cmd post-shutdown")
                }
                None => {
                    finish(&cic, disconnected(&uuid, Role::Sender, t_start)).await;
                    return Ok(());
                }
            }
        };

        let _ = bytes_written; // accounted for in agent's Done bytes
        finish(
            &cic,
            TunerResult {
                uuid: uuid.clone(),
                role: Role::Sender,
                outcome: TunerOutcome::Pass,
                bytes: final_bytes,
                elapsed: t_start.elapsed(),
            },
        )
        .await;
        Ok(())
    })
}

// ---------------------------------------------------------------------------
// spawn_receiver
// ---------------------------------------------------------------------------

/// Spawn a receiver tuner task.
pub fn spawn_receiver(
    uuid: String,
    mut cmd_rx: mpsc::Receiver<TunerCmd>,
    cic: CicHandle,
) -> tokio::task::JoinHandle<anyhow::Result<()>> {
    // ---
    tokio::spawn(async move {
        // ---
        let t_start = Instant::now();

        // --- wait for ephemeral port ---
        let port = loop {
            match cmd_rx.recv().await {
                Some(TunerCmd::Port(p)) => break p,
                Some(TunerCmd::Kill) => {
                    finish(&cic, killed(&uuid, Role::Receiver, t_start)).await;
                    return Ok(());
                }
                Some(other) => {
                    tracing::warn!(%uuid, ?other, "receiver: unexpected cmd awaiting port")
                }
                None => {
                    finish(&cic, disconnected(&uuid, Role::Receiver, t_start)).await;
                    return Ok(());
                }
            }
        };

        tracing::info!(%uuid, port, "receiver: connecting");

        // --- spawn blocking TCP reader ---
        let read_handle: tokio::task::JoinHandle<anyhow::Result<u64>> =
            tokio::task::spawn_blocking(move || {
                use std::io::Read;
                let mut tcp = std::net::TcpStream::connect(format!("127.0.0.1:{port}"))?;
                let mut buf = vec![0u8; 64 * 1024];
                let mut total = 0u64;
                loop {
                    let n = tcp.read(&mut buf)?;
                    if n == 0 {
                        break;
                    } // EOF
                    total += n as u64;
                }
                Ok(total)
            });

        // --- wait for Done / Failed from CIC ---
        let outcome = loop {
            match cmd_rx.recv().await {
                Some(TunerCmd::Done { .. }) => break TunerOutcome::Pass,
                Some(TunerCmd::Failed { reason, .. }) => {
                    read_handle.abort();
                    break TunerOutcome::Fail { reason };
                }
                Some(TunerCmd::Kill) => {
                    read_handle.abort();
                    finish(&cic, killed(&uuid, Role::Receiver, t_start)).await;
                    return Ok(());
                }
                Some(other) => tracing::warn!(%uuid, ?other, "receiver: unexpected cmd"),
                None => {
                    read_handle.abort();
                    finish(&cic, disconnected(&uuid, Role::Receiver, t_start)).await;
                    return Ok(());
                }
            }
        };

        let bytes = match read_handle.await {
            Ok(Ok(n)) => n,
            Ok(Err(e)) => {
                tracing::warn!(%uuid, "receiver read error: {e}");
                0
            }
            Err(_) => 0,
        };

        finish(
            &cic,
            TunerResult {
                uuid: uuid.clone(),
                role: Role::Receiver,
                outcome,
                bytes,
                elapsed: t_start.elapsed(),
            },
        )
        .await;
        Ok(())
    })
}

// ---------------------------------------------------------------------------
// Internal helpers
// ---------------------------------------------------------------------------

async fn finish(cic: &CicHandle, result: TunerResult) {
    // ---
    let _ = cic
        .tx
        .send(CicMsg::TunerFinished {
            uuid: result.uuid.clone(),
            role: result.role,
            result,
        })
        .await;
}

fn fail(uuid: &str, role: Role, reason: String, t_start: Instant) -> TunerResult {
    // ---
    TunerResult {
        uuid: uuid.to_string(),
        role,
        outcome: TunerOutcome::Fail { reason },
        bytes: 0,
        elapsed: t_start.elapsed(),
    }
}

fn killed(uuid: &str, role: Role, t_start: Instant) -> TunerResult {
    // ---
    tracing::warn!(%uuid, ?role, "tuner: killed by failsafe");
    fail(uuid, role, "killed by failsafe".into(), t_start)
}

fn disconnected(uuid: &str, role: Role, t_start: Instant) -> TunerResult {
    // ---
    tracing::warn!(%uuid, ?role, "tuner: CIC channel closed unexpectedly");
    fail(uuid, role, "CIC channel closed".into(), t_start)
}
